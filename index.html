<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTH-8">
    <title>Cercetari operationale</title>
    <style type="text/css">
        input[type="text"] {
            width: 2rem;
        }
        select {
            -webkit-appearance: none; /* For Safari and Chrome */
            -moz-appearance: none;    /* For Firefox */
            appearance: none;         /* Standard */
            width: 2rem;
        }
        select, input[type="text"] {
            height: 100%;
            padding: 0;
            text-align: center;
            border: 1px solid black;
            box-sizing: border-box;
            margin: 2px;
        }
        .equation {
            height: 2rem;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        textarea {
            height: 20rem;
            width: 20rem;
            padding: 1rem;
            font-size: 24px;
        }
        body {
            padding: 2rem;
        }
        #result {
            border: 2px solid black;
            border-radius: 4px;
            min-height: 5rem;
            width: 100%;
        }
        canvas {
            background-color: lightgray;
        }
        #exemple {
            display: flex;
            height: 15rem;
        }
        .exemplu {
            width: 10rem;
            height: 100%;
            border: 1px solid gray;
            padding: 8px;
        }
        h4 {
            margin: 0;
            margin-bottom: 8px;
        }
        #compute {
            background-color: aquamarine;
            margin: 8px;
        }
    </style>
</head>
<body>
    <!--div id="data">
        <h4>Tipul Problemei</h4>

        <form id="problem-type">
            <label>
                <input type="radio" name="option" value="minim">
                minim
            </label>
            <br>
            <label>
                <input type="radio" name="option" value="maxim">
                maxim
            </label>
        </form>
        
        <div id="equation1" class="equation-container" data-nr="1">
            <h4>Conditia 1</h4>
            <div class="equation">

                <select name="x1-sign" class="x1-sign">
                    <option value="+" selected>+</option>
                    <option value="-">-</option>
                </select>

                <input name="x1-coefficient" type="text" class="x1-coefficient">

                <span>&middot; X<sub>1</sub></span>

                <select name="x2-sign" class="x2-sign">
                    <option value="+" selected>+</option>
                    <option value="-">-</option>
                </select>

                <input name="x2-coefficient" type="text" class="x2-coefficient">

                <span>&middot; X<sub>2</sub></span>

                <select name="operator" class="operator">
                    <option value="le" selected>&le;</option>
                    <option value="ge">&ge;</option>
                </select>

                <input name="constant" type="text" class="constant">

            </div>
        </div>

    </div-->
    <h1>Cercetari Operationale - Metoda Grafica</h1>
    <div>Introduceti datele problemei conform formatului de mai jos, apoi apasati butonul "Calculeaza"</div>
    <div id="exemple">
        <div class="exemplu">
            <h4>Exemplul 1</h4>
            <span>max(4X1+ 7X2) <br>
            X1 + X2 &lt;= 6 <br>
            X1 - X2 &lt;= 2 <br>
            X2 >= 1 <br> 
            X1 >= 0 <br>
            X2 >= 0 <br><br>
            </span>
        </div>

        <div class="exemplu">
            <h4>Exemplul 2</h4>
            <span>min(0.4X1 + 0.6X2) <br>
            2X1 + 4X2 &gt;= 4 <br>
            6X1 + 3X2 &gt;= 6 <br>
            X1 >= 0 <br>
            X2 >= 0 <br><br>
            </span>
        </div>
    </div>
    <br>
    <h3>Datele problemei</h3>
    
    <div style="display:flex;">
        <div style="display: flex; flex-direction: column; margin-right: 1rem;;">

            
            <textarea></textarea>
            <button id="compute">Calculeaza</button>
            <h3>Rezultat</h3>
            <p id="result"></p>
        </div>
        <!--button id="new-condition">Adauga Conditie</button-->

        

        <canvas width="800" height="800" style="width:800px; height:800px;"></canvas>
    </div>

    <!--script src="script.js"></script-->

    <script>
        
var minPoints = [], maxPoints = [];

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.isValid = false;
        this.visited = false;
        this.equations = [];
    }
}

function newEquation() {
    const nodeList = document.querySelectorAll('.equation-container');
    const template = nodeList[nodeList.length - 1];
    const clone = template.cloneNode(true); // Clone the template
    const newNr = Number(template.dataset.nr) + 1;
    clone.dataset.nr = newNr;
    clone.id = 'equation' + newNr;
    clone.getElementsByTagName('h4')[0].textContent = 'Conditia ' + newNr;
    document.getElementById('data').appendChild(clone); // Add the clone
}

//newEquation();
//newEquation();

var equations = [];
var statement = {
    problemType: null,
    c1: null,
    c2: null
}

function getEquations() {
    equations = [];

    /*const collection = document.getElementsByClassName('equation');
    Array.from(collection).forEach(div => {
        s1 = (div.querySelector('.x1-sign').value == '+') ? 1 : -1;
        s2 = (div.querySelector('.x2-sign').value == '+') ? 1 : -1;
        c1 = div.querySelector('.x1-coefficient').value;
        c2 = div.querySelector('.x2-coefficient').value;
        operator = div.querySelector('.operator').value;
        constant = div.querySelector('.constant').value;

        if (c1 != '' && c2 != '' && constant != '') {
            const equation = {
                'c1' : s1 * Number(c1),
                'c2' : s2 * Number(c2),
                'operator' : operator,
                'constant' : Number(constant)
            };

            equations.push(equation);
        }
    });*/

    const input = document.querySelector('textarea').value;
    var regex = /^.*$/gm;
    const lines = [...input.matchAll(regex)];

    //console.log(lines);

    lines.forEach(line => {
        var c1, c2;

        regex = /([+-]?)\s*(\d*)\s*x1/i;
        var matches = line[0].match(regex);
        if (matches == null) {
            c1 = 0;
        }
        else if (matches[2] == '') {
            c1 = (matches[1] == '-') ? -1 : +1;
        }
        else {
            c1 = ((matches[1] == '-') ? -1 : +1) * Number(matches[2].replace(' ', ''));
        }

        regex = /([+-]?)\s*(\d*)\s*x2/i;
        var matches = line[0].match(regex);
        if (matches == null) {
            c2 = 0;
        }
        else if (matches[2] == '') {
            c2 = (matches[1] == '-') ? -1 : +1;
        }
        else {
            c2 = ((matches[1] == '-') ? -1 : +1) * Number(matches[2].replace(' ', ''));
        }

        //linia cu max sau min
        //console.log(line[0]);
        if (/(max|min)/i.test(line[0])) {
            if (/max/i.test(line[0])) {
                statement.problemType = 'max';
            }
            else {
                statement.problemType = 'min';
            }
            statement.c1 = c1;
            statement.c2 = c2;
        }
        else if (/x/i.test(line[0])) { 
            regex = /(<=|>=)/;
            const operator = line[0].match(regex);
    
            regex = /=\s*[+-]?\s*\d+/;
            const constant = Number(line[0].match(regex)[0].replace(/[=\s*]/g, ''));

            var equation = {
                'c1': c1,
                'c2': c2,
                'operator' : operator[1],
                'constant': constant
            }
            equations.push(equation);
        }
    })

    console.log(statement);
    console.log(equations);
}

var points = [new Point(0, 0)];

function getPoints() {
    points = [new Point(0, 0)];

    for (var i = 0; i < equations.length; i++) {
        const ei = equations[i];

        /*/intersection with x1 axis
        x2 = 0;
        x1 = ei.constant / ei.c1;
        points.push(new Point(x1, x2));

        //intersection with x2 axis
        x1 = 0;
        x2 = ei.constant / ei.c2;
        points.push(new Point(x1, x2));*/

        //intersection with other equations
        for (var j = i + 1; j < equations.length; j++) {
            const ej = equations[j];

            //metoda determinantilor
            const det = ej.c1 * ei.c2 - ei.c1 * ej.c2;

            //daca det = 0, nu exista solutie, treci la urmatoarea ecuatie
            if (det == 0) {
                continue;
            }

            //calculeaza determinatnul pentru x si y
            const detX = ej.constant * ei.c2 - ei.constant * ej.c2;
            const detY = ej.c1 * ei.constant - ei.c1 * ej.constant;

            // solutia
            var x = detX / det;
            var y = detY / det;

            if (x == -0) x = 0;
            if (y == -0) y = 0;

            p = new Point(x, y);
            p.equations.push(ei, ej);
            points.push(p);
        }
    }

    console.log(points);
}

function isValid(equation, x1, x2) {
    sum = equation.c1 * x1 + equation.c2 * x2;
    
    if (equation.operator == "<=") {
        return sum <= equation.constant;
    }
    else if (equation.operator == ">=") {
        return sum >= equation.constant;
    }
}

function getValidPoints() {
    points.forEach(point => {
        var sw = true;
        equations.forEach(equation => {
            //console.log(equation, point.x, point.y, isValid(equation, point.x, point.y))
            if (!isValid(equation, point.x, point.y)) {
               sw = false;
            }
        });
        point.isValid = sw;
    })

    //remove duplicates
    for (var i = 0; i < points.length; i++) {
        for (var j = i + 1; j < points.length; j++) {
            if (points[i].x == points[j].x && points[i].y == points[j].y) {
                points[j].isValid = false;
            }
        }
    }

    console.log('Valid points: ', points.filter(point => point.isValid == true));
}

var min, max;

function getSolutions() {
    minPoints = [], maxPoints = [];
    min = undefined;
    max = undefined;

    for (i = 0; i < points.length; i++) {
        if (points[i].isValid) {
            var result = statement.c1 * points[i].x + statement.c2 * points[i].y;
            //console.log(result);
            //console.log(i);
            if (result < min || min == undefined) {
                min = result;
                minPoints = [points[i]];
            }
            else if (result == min) {
                minPoints.push(points[i]);
            }

            if (result > max || max == undefined) {
                max = result;
                maxPoints = [points[i]];
            }
            else if (result == max) {
                maxPoints.push(points[i]);
            }
        }
    }

    const p = document.querySelector('#result');
    if (statement.problemType == 'max') {
        console.log('max', max, maxPoints);
        p.innerHTML = 'max(f) = ' + max + '<br>' +
                        'Multimea solutiilor optime: S<sub>o</sub> = {' + maxPoints.map((point, index) => `${String.fromCharCode(65 + index)}(${point.x}, ${point.y})`).join(', ') + '}';
    }
    else {
        console.log('min', min, minPoints);
        p.innerHTML = 'min(f) = ' + min + '<br>' +
                        'Multimea solutiilor optime: S<sub>o</sub> = {' + minPoints.map((point, index) => `${String.fromCharCode(65 + index)}(${point.x}, ${point.y})`).join(', ') + '}';
    }
}

const computeBtn = document.querySelector('#compute');
computeBtn.addEventListener('click', () => {
    getEquations();
    getPoints();
    getValidPoints();
    getSolutions();
    draw();
});

/*const newConditionBtn = document.querySelector('#new-condition');
newConditionBtn.addEventListener('click', () => {
    newEquation();
});*/




const canvas = document.querySelector('canvas');
var scale = window.devicePixelRatio;
//console.log(scale);
var w = 800;
var h = 800;

canvas.width = w;
canvas.height = h;
canvas.style.width = w / scale + "px";
canvas.style.height = h / scale + "px";


function draw() {

    const canvas = document.querySelector('canvas');
    var scale = window.devicePixelRatio;
    //console.log(scale);
    var w = 800;
    var h = 800;

canvas.width = w;
canvas.height = h;
canvas.style.width = w / scale + "px";
canvas.style.height = h / scale + "px";

const c = canvas.getContext('2d');
c.resetTransform();
c.clearRect(0, 0, 2*w, 2*h);
//set origin to center and flip y axis
c.translate(w/2, h/2);
c.scale(scale, -scale);
w /= scale;
h /= scale;

//get furthest point
var dMax = 0;
for (var i = 0; i < points.length; i++) {
    var d = Math.max(Math.abs(points[i].x), Math.abs(points[i].y));
    if (d > dMax) {
        dMax = d;
    }
    //console.log('dMax = ' + dMax)
}
//set scale
c.scale(w * 0.9 / 2 / dMax, h * 0.9 / 2 / dMax);
scale /= (w * 0.9 / 2 / dMax);
w /= (0.9 / 2 / dMax);
h /= (0.9 / 2 / dMax);

c.lineWidth = 4 * scale;
c.strokeStyle = 'blue';
c.beginPath();
c.moveTo(0, -h);
c.lineTo(0, h);
c.stroke();

c.beginPath();
c.moveTo(-w, 0);
c.lineTo(w, 0);
c.stroke();
c.strokeStyle = 'black';
c.lineWidth = 2 * scale;

equations.forEach(eq => {
    c.beginPath();

    if (eq.c2 == 0) {
        x1 = eq.constant / eq.c1;
        x2 = -h * scale;
        c.moveTo(x1, x2);

        //console.log(x1, x2);

        x2 = h * scale;
        c.lineTo(x1, x2);
    }
    else {
        x1 = -w * scale;
        x2 = (eq.constant - eq.c1 * x1) / eq.c2;
        c.moveTo(x1, x2);

        //console.log(x1, x2);

        x1 = w * scale;
        x2 = (eq.constant - eq.c1 * x1) / eq.c2;
        c.lineTo(x1, x2);
    }

    c.stroke();    
    //console.log(x1, x2);
})

var current = null;
c.fillStyle = 'lightblue';
c.beginPath();
for (var i = 0; i < points.length; i++) {
    if (points[i].isValid == true) {
        current = points[i];
        current.visted = true;
        console.log('current', current);
        c.moveTo(current.x, current.y);
        break;
    }
}
while(true) {
    var sw = false;
    for (var j = 0; j < points.length; j++) {
        //console.log(current.equations.filter(e => points[j].equations.includes(e)));
        if (points[j].isValid == true && points[j].visited == false && current.equations.some(e => points[j].equations.includes(e))) {
            current = points[j];
            current.visited = true;
            console.log('current', current);
            c.lineTo(current.x, current.y);
            sw = true;
            break;
        }
    }
    if (sw == false) {
        break;
    }
}
c.closePath();
c.fill();


c.fillStyle = 'red';
//console.log(statement);
//console.log(minPoints);
//console.log(maxPoints);
if (statement.problemType == 'max') {
    maxPoints.forEach(p => {
        c.beginPath();
        c.arc(p.x, p.y, 3 * c.lineWidth, 0, 2 * Math.PI);
        c.fill();
    })
}
else if (statement.problemType == 'min') {
    minPoints.forEach(p => {
        c.beginPath();
        c.arc(p.x, p.y, 3 * c.lineWidth, 0, 2 * Math.PI);
        c.fill();
        console.log('min', p);
    })
}
c.fillStyle = 'black';

}


    </script>
</body>
</html>